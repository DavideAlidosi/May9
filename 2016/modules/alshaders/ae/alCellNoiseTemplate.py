import pymel.core as pm
from alShaders import *

class AEalCellNoiseTemplate(alShadersTemplate):
	controls = {}
	params = {}
	def setup(self):
		self.params.clear()
		self.params["space"] = Param("space", "Space", "Space in which to calculate the noise pattern.", "enum", presets=None)
		self.params["frequency"] = Param("frequency", "Frequency", "Frequency of the noise pattern. Larger numbers make it smaller, lower numbers make it bigger.", "float", presets=None)
		self.params["mode"] = Param("mode", "Mode", "Features allows you to measure the distance to features to create veiny textures, chips simply puts a random color in each block.", "enum", presets=None)
		self.params["randomness"] = Param("randomness", "Randomness", "How much randomness is added to the cel positions.", "float", presets=None)
		self.params["octaves"] = Param("octaves", "Octaves", "Number of octaves to calculate. Higher numbers give more detail but take longer to compute.", "int", presets=None)
		self.params["lacunarity"] = Param("lacunarity", "Lacunarity", "How much the frequency is increased with each octave.", "float", presets=None)
		self.params["RMPinputMin"] = Param("RMPinputMin", "Input min", "Sets the minimum input value. Use this to pull values outside of 0-1 into a 0-1 range.", "float", presets=None)
		self.params["RMPinputMax"] = Param("RMPinputMax", "Input max", "Sets the maximum input value. Use this to pull values outside of 0-1 into a 0-1 range.", "float", presets=None)
		self.params["RMPcontrast"] = Param("RMPcontrast", "Contrast", "Scales the contrast of the input signal.", "float", presets=None)
		self.params["RMPcontrastPivot"] = Param("RMPcontrastPivot", "Pivot", "Sets the pivot point around which the input signal is contrasted.", "float", presets=None)
		self.params["RMPbias"] = Param("RMPbias", "Bias", "Bias the signal higher or lower. Values less than 0.5 push the average lower, values higher than 0.5 push it higher.", "float", presets=None)
		self.params["RMPgain"] = Param("RMPgain", "Gain", "Adds gain to the signal, in effect a different form of contrast. Values less than 0.5 increase the gain, values greater than 0.5 decrease it.", "float", presets=None)
		self.params["RMPoutputMin"] = Param("RMPoutputMin", "Output min", "Sets the minimum value of the output. Use this to scale a 0-1 signal to a new range.", "float", presets=None)
		self.params["RMPoutputMax"] = Param("RMPoutputMax", "Output max", "Sets the maximum value of the output. Use this to scale a 0-1 signal to a new range.", "float", presets=None)
		self.params["RMPclampEnable"] = Param("RMPclampEnable", "Enable", "When enabled, will clamp the output to Min-Max.", "bool", presets=None)
		self.params["RMPthreshold"] = Param("RMPthreshold", "Expand", "When enabled, will expand the clamped range to 0-1 after clamping.", "bool", presets=None)
		self.params["RMPclampMin"] = Param("RMPclampMin", "Min", "Minimum value to clamp to.", "float", presets=None)
		self.params["RMPclampMax"] = Param("RMPclampMax", "Max", "Maximum value to clamp to.", "float", presets=None)
		self.params["color1"] = Param("color1", "Color 1", "Color to use when the noise result is 0.", "rgb", presets=None)
		self.params["color2"] = Param("color2", "Color 2", "Color to use when the noise result is 1.", "rgb", presets=None)
		self.params["smoothChips"] = Param("smoothChips", "Smooth", "Smooth the chip colors.", "bool", presets=None)
		self.params["randomChips"] = Param("randomChips", "Randomize", "Give each chip a randomly-generated color.", "bool", presets=None)
		self.params["chipColor1"] = Param("chipColor1", "Chip color 1", "Color of the first set of chips", "rgb", presets=None)
		self.params["chipProb1"] = Param("chipProb1", "Chip probability 1", "Probability of the cell being the first color.", "float", presets=None)
		self.params["chipColor2"] = Param("chipColor2", "Chip color 2", "Color of the second set of chips", "rgb", presets=None)
		self.params["chipProb2"] = Param("chipProb2", "Chip probability 2", "Probability of the cell being the second color.", "float", presets=None)
		self.params["chipColor3"] = Param("chipColor3", "Chip color 3", "Color of the third set of chips", "rgb", presets=None)
		self.params["chipProb3"] = Param("chipProb3", "Chip probability 3", "Probability of the cell being the third color.", "float", presets=None)
		self.params["chipColor4"] = Param("chipColor4", "Chip color 4", "Color of the fourth set of chips", "rgb", presets=None)
		self.params["chipProb4"] = Param("chipProb4", "Chip probability 4", "Probability of the cell being the fourth color.", "float", presets=None)
		self.params["chipColor5"] = Param("chipColor5", "Chip color 5", "Color of the fifth set of chips", "rgb", presets=None)
		self.params["chipProb5"] = Param("chipProb5", "Chip probability 5", "Probability of the cell being the fifth color.", "float", presets=None)
		self.params["P"] = Param("P", "P", "Connect a point here to define a custom space for the noise to be calculated in. You can use alInputVector to get and transform points. This can be useful for animating noises in coordinate systems.", "vector", presets=None)

		self.addSwatch()
		self.beginScrollLayout()

		self.addControl("space", label="Space", annotation="Space in which to calculate the noise pattern.")
		self.addCustomFlt("frequency")
		self.addControl("mode", label="Mode", annotation="Features allows you to measure the distance to features to create veiny textures, chips simply puts a random color in each block.")
		self.addCustomFlt("randomness")
		self.beginLayout("Features", collapse=False)
		self.addControl("octaves", label="Octaves", annotation="Number of octaves to calculate. Higher numbers give more detail but take longer to compute.")
		self.addCustomFlt("lacunarity")
		self.beginLayout("Remap", collapse=True)
		self.addCustomFlt("RMPinputMin")
		self.addCustomFlt("RMPinputMax")
		self.beginLayout("Contrast", collapse=False)
		self.addCustomFlt("RMPcontrast")
		self.addCustomFlt("RMPcontrastPivot")
		self.endLayout() # END Contrast
		self.beginLayout("Bias and gain", collapse=False)
		self.addCustomFlt("RMPbias")
		self.addCustomFlt("RMPgain")
		self.endLayout() # END Bias and gain
		self.addCustomFlt("RMPoutputMin")
		self.addCustomFlt("RMPoutputMax")
		self.beginLayout("Clamp", collapse=False)
		self.addControl("RMPclampEnable", label="Enable", annotation="When enabled, will clamp the output to Min-Max.")
		self.addControl("RMPthreshold", label="Expand", annotation="When enabled, will expand the clamped range to 0-1 after clamping.")
		self.addCustomFlt("RMPclampMin")
		self.addCustomFlt("RMPclampMax")
		self.endLayout() # END Clamp
		self.endLayout() # END Remap
		self.addCustomRgb("color1")
		self.addCustomRgb("color2")
		self.endLayout() # END Features
		self.beginLayout("Chips", collapse=False)
		self.addControl("smoothChips", label="Smooth", annotation="Smooth the chip colors.")
		self.addControl("randomChips", label="Randomize", annotation="Give each chip a randomly-generated color.")
		self.addCustomRgb("chipColor1")
		self.addCustomFlt("chipProb1")
		self.addCustomRgb("chipColor2")
		self.addCustomFlt("chipProb2")
		self.addCustomRgb("chipColor3")
		self.addCustomFlt("chipProb3")
		self.addCustomRgb("chipColor4")
		self.addCustomFlt("chipProb4")
		self.addCustomRgb("chipColor5")
		self.addCustomFlt("chipProb5")
		self.endLayout() # END Chips
		self.addControl("P", label="P", annotation="Connect a point here to define a custom space for the noise to be calculated in. You can use alInputVector to get and transform points. This can be useful for animating noises in coordinate systems.")

		pm.mel.AEdependNodeTemplate(self.nodeName)
		self.addExtraControls()

		self.endScrollLayout()
